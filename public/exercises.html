<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>View Exercise</title>
  <link rel="stylesheet" href="styles/exercises.css"/>
</head>
<body>
  <h1>Exercise Details</h1>
  <div id="exercise-details"></div>
  <div id="status" style="margin-top:1em; font-style:italic;"></div>
  <div id="back"></div>

  <script>
    // --- Levenshtein distance (for small strings, O(n*m) is fine) ---
    function levenshtein(a, b) {
      const m = a.length, n = b.length;
      const dp = Array.from({length: m+1}, () => new Array(n+1));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          dp[i][j] = Math.min(
            dp[i-1][j] + 1,
            dp[i][j-1] + 1,
            dp[i-1][j-1] + (a[i-1] === b[j-1] ? 0 : 1)
          );
        }
      }
      return dp[m][n];
    }

    async function loadExercise() {
      // 1) load translations.json → build English→Conlang lookup
      const translationsArray = await fetch('translations.json')
        .then(r => r.json())
        .catch(e => { console.error('Failed to load translations.json', e); return []; });
  
      const enToCl = Object.fromEntries(
        translationsArray.map(({conlang, translation}) => [translation.toLowerCase(), conlang])
      );
  
      // 2) load exercise data
      const params = new URLSearchParams(window.location.search);
      const lessonId = params.get('lesson_id');
      const exerciseId = params.get('exercise_id');
      if (!lessonId || !exerciseId) {
        document.getElementById('exercise-details')
          .innerText = 'Missing lesson_id or exercise_id in URL';
        return;
      }
  
      const exercises = await fetch(`/api/exercises?lesson_id=${lessonId}`)
        .then(r => r.json())
        .catch(e => {
          console.error('Failed to load exercises', e);
          document.getElementById('exercise-details')
            .innerText = 'Failed to load exercise data';
          return [];
        });
  
      const exercise = exercises.find(ex => ex.id === exerciseId);
      if (!exercise) {
        document.getElementById('exercise-details')
          .innerText = 'Exercise not found';
        return;
      }
  
      // 3) render prompt, splitting on whitespace but preserving it
      const rawPrompt = exercise.prompt;
      // split into words *and* whitespace chunks
      const tokens = rawPrompt.split(/(\s+)/);
      const promptHtml = tokens.map(token => {
        // if it's purely whitespace, leave it alone
        if (/^\s+$/.test(token)) return token;
        // strip trailing punctuation for lookup
        const key = token.replace(/^[“"‘'([{]+|[.,!?:;”"’'\])}]+$/g, '').toLowerCase();
        const cl = enToCl[key] || '(no entry)';
        return `<span class="trans-word" data-word="${key}" title="${cl}">${token}</span>`;
      }).join('');
  
      // 4) put it into the page
      const details = document.getElementById('exercise-details');
      details.innerHTML = `
        <h2>${promptHtml}</h2>
        <div id="options-container"></div>
      `;
      document.getElementById('back').innerHTML =
        `<a href="lessons?lesson_id=${lessonId}">Back</a>`;
  
      // 5) render multiple-choice buttons (unchanged)
      if (exercise.type === 'multiple_choice') {
        const options = JSON.parse(exercise.options);
        const correct = exercise.correct_answer;
        const statusDiv = document.getElementById('status');
        const optsCon = document.getElementById('options-container');
  
        options.forEach(opt => {
          const btn = document.createElement('button');
          btn.textContent = opt;
          btn.addEventListener('click', () => {
            if (opt === correct) {
              btn.style.backgroundColor = 'lightgreen';
              statusDiv.textContent = '✅ Correct!';
            } else {
              btn.style.backgroundColor = 'salmon';
              statusDiv.textContent = '❌ Incorrect. Try again!';
            }
          });
          optsCon.appendChild(btn);
        });
      }
  
      // 6) attach hover behavior to all the prompt-word spans
      // after rendering promptHtml and options...

      // keep the full translations array around

      const statusDiv = document.getElementById('status');

      document.querySelectorAll('.trans-word').forEach(span => {
        const key = span.dataset.word; // already lowercased
        span.style.cursor = 'help';

        span.addEventListener('mouseenter', () => {
          // 1) find all entries whose English gloss contains the key
          const matches = translationsArray
            .filter(({translation}) =>
              translation.toLowerCase().includes(key)
            )
            .map(entry => ({
              conlang: entry.conlang,
              translation: entry.translation,
              dist: levenshtein(entry.translation.toLowerCase(), key)
            }))
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 10);                     // only the first 10

          if (matches.length === 0) {
            statusDiv.textContent = '(no matches)';
            span.title = '(no matches)';
          } else {
            // build "conlang: translation" lines
            const lines = matches.map(m => `${m.conlang}: ${m.translation}`);
            const text = lines.join('\n');
            statusDiv.textContent = text;
            span.title = text;               // native tooltip
          }
        });

        span.addEventListener('mouseleave', () => {
          statusDiv.textContent = '';
        });
      });
    }
  
    loadExercise();
  </script>
  
</body>
</html>
